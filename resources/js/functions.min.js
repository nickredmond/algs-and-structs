/**
	Various sorting algorithms for lists of non-negative integers
*/

/**
	Summary: Divides into sub-arrays, sorts sub-arrays, and then merges sub-arrays
	Efficiency: O(n log n)
*/
var merge_sort = function(list, step_callback) {
	var result = [];

	if (list.length > 1) {
		var median = list.length / 2;
		var leftList = list.slice(0, median);
		var rightList = list.slice(median, list.length);
		var sortedLeft = merge_sort(leftList, step_callback);
		var sortedRight = merge_sort(rightList, step_callback);

		var leftIndex = 0;
		var rightIndex = 0;

		var leftLength = sortedLeft.length;
		var rightLength = sortedRight.length;
		while (leftIndex < leftLength && rightIndex < rightLength) {
			if (sortedLeft[leftIndex] < sortedRight[rightIndex]) {
				result.push(sortedLeft[leftIndex]);
				leftIndex += 1;
			}
			else {
				result.push(sortedRight[rightIndex]);
				rightIndex += 1;
			}
		}

		while (leftIndex < leftLength) {
			result.push(sortedLeft[leftIndex]);
			leftIndex += 1;
		}
		while (rightIndex < rightLength) {
			result.push(sortedRight[rightIndex]);
			rightIndex += 1;
		}
	}
	else {
		result = list;
	}
	step_callback({ "sorted_sublist": result });

	return result;
};

/** 
	Summary: Bubbles largest unsorted element to end of list
	Efficiency: O(n^2) 
*/
var bubble_sort = function(list, step_callback) {
	var sortedList = list;
	var isSorted = false;

	for (var i = 0; i < list.length && !isSorted; i++) {
		var unsortedLength = list.length - i;
		isSorted = true;

		for (var j = 0; j < unsortedLength - 1; j++) {
			var left = sortedList[j];
			var right = sortedList[j + 1];
			if (left > right) {
				isSorted = false;
				sortedList[j + 1] = left;
				sortedList[j] = right;
			}
			step_callback({ "sorted_list": sortedList });
		}
	}

	return sortedList;
};

/**
	Summary: Removes elements from unsorted list and inserts them into sorted list
	Efficiency: O(n^2)
*/
var insertion_sort = function(list, step_callback) {
	var sortedList = list;

	for (var i = 0; i < list.length; i++) {
		var nextElement = sortedList[i];
		var shiftedElement = null;
		for (var j = 0; j <= i; j++) {
			if (shiftedElement !== null) {
				var blockingElement = sortedList[j];
				sortedList[j] = shiftedElement;
				shiftedElement = blockingElement;
			}
			else if (nextElement < sortedList[j]) {
				shiftedElement = sortedList[j];
				sortedList[j] = nextElement;
			}
		}

		step_callback({ "sorted_list": sortedList });
	}
	
	return sortedList;
};

/** 
	Summary: Selects smallest unsorted element and brings it to the front
	Efficiency: O(n^2)
*/
var selection_sort = function(list, step_callback) {
	var sortedList = list;

	for (var i = 0; i < sortedList.length - 1; i++) {
		var smallestIndex = i;
		for (var j = i + 1; j < sortedList.length; j++) {
			if (sortedList[j] < sortedList[smallestIndex]) {
				smallestIndex = j;
			}
		}

		var smallestValue = sortedList[smallestIndex];
		sortedList[smallestIndex] = sortedList[i];
		sortedList[i] = smallestValue;
		step_callback({ "sorted_list": sortedList });
	}

	return sortedList;
};

/** 
	Summary: Fills empty buckets with occurences of each element
	Efficiency: O(n)
*/
var bucket_sort = function(list, step_callback) {
	var maxValue = 0;
	for (var i = 0; i < list.length; i++) {
		maxValue = Math.max(maxValue, list[i]);
	}
	step_callback({ "max_value": maxValue });

	var buckets = Array(maxValue + 1).fill(0);
	for (var i = 0; i < list.length; i++) {
		var bucketIndex = list[i];
		buckets[bucketIndex] += 1;
	}
	step_callback({ "buckets": buckets })

	var sortedList = [];
	for (var i = 0; i < buckets.length; i++) {
		var bucketCount = buckets[i];
		for (var j = 0; j < bucketCount; j++) {
			sortedList.push(i);
			step_callback({ "sorted_list": sortedList });
		}
	}

	return sortedList;
};

var sortList = function(list, algorithm, algorithmName) {
	console.log("--- " + algorithmName.toUpperCase() + " ---");
	console.log("LIST: " + JSON.stringify(list));
	var result = algorithm(list, function(data) {
		console.log(JSON.stringify(data));
	});
	console.log("RESULT: " + JSON.stringify(result) + "\n");
};

var generateList = function(min, max, count) {
	var list = [];
	var range = max - min;

	for (var i = 0; i < count; i++) {
		var number = Math.floor(Math.random() * range + min);
		list.push(number);
	}

	return list;
};

var list = generateList(0, 15, 11);
sortList(list, bucket_sort, "bucket sort");

list = generateList(0, 15, 11);
sortList(list, bubble_sort, "bubble sort");

list = generateList(0, 15, 11);
sortList(list, selection_sort, "selection sort");

list = generateList(0, 15, 11);
sortList(list, insertion_sort, "insertion sort");

list = generateList(0, 15, 11);
sortList(list, merge_sort, "merge-sort");